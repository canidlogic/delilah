<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Delilah Viewer</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"/>
    <style>

body {
  padding-left: 0.25em;
  padding-right: 0.25em;
  margin-bottom: 3.5em;
  background-color: WhiteSmoke;
  color: black;
  font-family: serif;
}

:link {
  text-decoration: none;
  color: blue
}

:visited {
  text-decoration: none;
  color: blue
}

h1 {
  font-family: sans-serif;
}

#divSplash {
  font-style: italic;
}

#divMain {
  display: none;
}

#cnvMain {
 border: medium inset;
 padding: 0;
}

#divSizer {
  margin-top: 1em;
}

#divFileError {
  display: none;
  margin-top: 2em;
  font-weight: bold;
  color: red;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-top: 1em;
  padding-bottom: 1em;
  border: medium solid;
  background-color: white;
}

#spnFileReason {
  font-weight: normal;
  color: black;
}

#divFile {
  margin-top: 1em;
}

#divCamError {
  display: none;
  margin-top: 2em;
  font-weight: bold;
  color: red;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-top: 1em;
  padding-bottom: 1em;
  border: medium solid;
  background-color: white;
}

#spnCamReason {
  font-weight: normal;
  color: black;
}

#divCam {
  margin-top: 1em;
}

#divCam th {
  font-weight: normal;
  text-align: left;
  text-decoration: underline;
  padding-bottom: 0.5em;
}

#divCam .lbl {
  text-align: right;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divCam .suf {
  text-align: left;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divCam .box input {
  width: 5em;
}

#divCam .abox input {
  width: 3em;
}

#divCam .btn {
  text-align: left;
  padding-top: 0.5em;
}
  
    </style>
    <!-- If JavaScript disabled, do not show the splash screen -->
    <noscript>
      <style>

#divSplash {
  display: None;
}

      </style>
    </noscript>

    <!-- Load JavaScript modules -->
    <script src="dla.js"></script>
    
    <!-- Embedded script is for presentation tier functionality -->
    <script>

// Wrap everything in an anonymous function that we immediately invoke
// after it is declared -- this prevents anything from being implicitly
// added to global scope
(function() {

  /*
   * Local data
   * ==========
   */
  
  /*
   * Flag set to true when a file load is in progress.
   */
  var m_file_load = false;

  /*
   * Local functions
   * ===============
   */
  
  /*
   * Report an error to console and throw an exception for a fault
   * occurring within this module.
   *
   * Parameters:
   *
   *   func_name : string - the name of the function in this module
   *
   *   loc : number(int) - the location within the function
   */
  function fault(func_name, loc) {
    
    // If parameters not valid, set to unknown:0
    if ((typeof func_name !== "string") || (typeof loc !== "number")) {
      func_name = "unknown";
      loc = 0;
    }
    loc = Math.floor(loc);
    if (!isFinite(loc)) {
      loc = 0;
    }
    
    // Report error to console
    console.log("Fault at " + func_name + ":" + String(loc) +
                  " in dla_html");
    
    // Throw exception
    throw ("dla_html:" + func_name + ":" + String(loc));
  }
  
  /*
   * Find the element with the given ID and set its innerHTML to the
   * given message.
   *
   * This function will properly escape any & < > characters in the
   * message.
   *
   * Also, the given string will be trimmed of whitespace.  If this
   * results in an empty string, the string will be replaced with
   * "&nbsp;"
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to set
   *
   *   msg : string - the (unescaped) message to set
   */
  function writeTo(elid, msg) {
    
    var func_name = "present";
    var e;
    
    // Check parameters
    if ((typeof elid !== "string") || (typeof msg !== "string")) {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Trim message
    msg = msg.trim();
    
    // Escape the & characters first
    msg = msg.replace("&", "&amp;");
    
    // Escape the < > characters second
    msg = msg.replace("<", "&lt;");
    msg = msg.replace(">", "&gt;");
    
    // Finally, if message is empty, replace with &nbsp;
    if (msg.length < 1) {
      msg = "&nbsp;";
    }
    
    // Write the message
    e.innerHTML = msg;
  }
  
  /*
   * Find the element with the given ID and set its display property to
   * "block" to show it.
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to show
   */
  function present(elid) {
    
    var func_name = "present";
    var e;
    
    // Check parameter
    if (typeof elid !== "string") {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Show the element
    e.style.display = "block";
  }
  
  /*
   * Redraw the scene in the canvas.
   */
  function drawCanvas() {
    
    var func_name = "drawCanvas";
    var eCanvas;
    var rc, w, h;
    
    // Get the canvas element
    eCanvas = document.getElementById("cnvMain");
    if (eCanvas == null) {
      fault(func_name, 100);
    }
    
    // Get the width and height
    w = eCanvas.width;
    h = eCanvas.height;
    
    // Only proceed if both width and height are greater than zero
    if ((w > 0) && (h > 0)) {
      
      // Get a 2D rendering context
      rc = eCanvas.getContext("2d");
      if (rc == null) {
        fault(func_name, 200);
      }
      
      // Do full render if both width and height are greater than one,
      // else just blank to transparent black
      if ((w > 1) && (h > 1)) {
        dla_main.renderScene(rc, w, h);
        
      } else {
        rc.clearRect(0, 0, w, h);
      }
    }
  }

  /*
   * Event handler for handling changes to the canvas size option box.
   */
  function resizeChanged() {
    
    var func_name = "resizeChanged";
    var eOpt;
    var eCanvas;
    var sv;
    var sza;
    var i;
    var j;
    var c;
    var new_width;
    var new_height;
    
    // Get the size option control and the canvas
    eOpt = document.getElementById("optSize");
    eCanvas = document.getElementById("cnvMain");
    
    if ((eOpt == null) || (eCanvas == null)) {
      fault(func_name, 100);
    }
    
    // Get the string value of the option control
    sv = eOpt.value;
    
    // String value must be at least seven characters to be valid
    if (sv.length < 7) {
      fault(func_name, 200);
    }
    
    // First four characters must be "size"
    if (sv.slice(0, 4) !== "size") {
      fault(func_name, 300);
    }
    
    // Drop the first four characters
    sv = sv.slice(4);
    
    // Rest of the string value should be split around an "x" delimiter
    sza = sv.split("x");
    if (sza.length !== 2) {
      fault(func_name, 400);
    }
    
    // Both of the field elements should be at least one character
    if ((sza[0].length < 1) || (sza[1].length < 1)) {
      fault(func_name, 500);
    }
    
    // Both field elements should only have decimal digits
    for(j = 0; j < sza.length; j++) {
      for(i = 0; i < sza[j].length; i++) {
        c = sza[j].charCodeAt(i);
        if ((c < 0x30) || (c > 0x39)) {
          fault(func_name, 600);
        }
      }
    }
    
    // We can now get the desired width and height
    new_width = parseInt(sza[0], 10);
    new_height = parseInt(sza[1], 10);
    
    if ((!isFinite(new_width)) || (!isFinite(new_height))) {
      fault(func_name, 650);
    }
    
    // Check that new width and height are at least two
    if ((new_width < 2) || (new_height < 2)) {
      fault(func_name, 675);
    }
    
    // Ignore the event if new width and height same as current
    // dimensions
    if ((new_width === eCanvas.width) && 
        (new_height === eCanvas.height)) {
      return;
    }
    
    // If we got here, resize the canvas
    eCanvas.width = new_width;
    eCanvas.height = new_height;
    
    // Redraw canvas
    drawCanvas();
  }

  /*
   * Event handler for when the scene file control is changed.
   */
  function handleFile(event) {
    
    var func_name = "handleFile";
    var e;
    var f, r;
    
    // If file load already in progress, ignore this event
    if (m_file_load) {
      return;
    }
    
    // Dismiss the file error if it is being displayed
    dismiss("divFileError");
    
    // Get the file control
    e = document.getElementById("uplFile");
    if (e == null) {
      fault(func_name, 100);
    }
    
    // Check whether at least one file selected
    if (e.files.length > 0) {
      // At least one file selected, so get the file object
      f = e.files.item(0);
      
      // We don't want to get another file while we are waiting for the
      // current file to load, so hide the DIV containing the control
      // and set the m_file_load flag
      e = document.getElementById("divFile");
      if (e == null) {
        fault(func_name, 200);
      }
      e.style.display = "none";
      m_file_load = true;
      
      // Get a file reader object
      r = new FileReader();
      
      // Add an asynchronous handler that is always called at the end of
      // the operation, whether successful or not, that will clear the
      // file load flag and show the file DIV again
      r.addEventListener("loadend", function(ev) {
        m_file_load = false;
        e.style.display = "block";
      });
      
      // Define an asynchronous handler that will be invoked once the
      // whole file has been successfully read as a string
      r.addEventListener("load", function(ev) {
        
        // Load the scene, redrawing canvas if successful, showing error
        // message if unsuccessful
        if (dla_main.loadScene(ev.target.result)) {
          drawCanvas();
        } else {
          writeTo("spnFileReason", dla_main.loadError());
          present("divFileError");
        }
      });
      
      // Asynchronously read the file as text
      r.readAsText(f);
      
    } else {
      // No files selected, so load default scene
      dla_main.loadDefaultScene();
    }
  }

  /*
   * Public functions
   * ================
   */
  
  /*
   * Find the element with the given ID and set its display property to
   * "none" to hide it.
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to hide
   */
  function dismiss(elid) {
    
    var func_name = "dismiss";
    var e;
    
    // Check parameter
    if (typeof elid !== "string") {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Hide the element
    e.style.display = "none";
  }
  
  /*
   * Read the current camera position and update the display controls
   * with the current position.
   *
   * This also hides any camera error message that may be displayed.
   */
  function readCamera() {
    
    var func_name = "readCamera";
    var cpos;
    var x, n;
    var eX, eY, eZ, eYaw, ePitch, eRoll;
    
    // Dismiss any camera error
    dismiss("divCamError");
    
    // Get the camera position
    cpos = dla_main.getCamera();
    
    // Convert normalized angles to degrees
    cpos[3] = cpos[3] * 360.0;
    cpos[4] = cpos[4] * 90.0;
    cpos[5] = cpos[5] * 360.0;
    
    // Transform each coordinate to a string, using one decimal place
    for(x = 0; x < 6; x++) {
      n = cpos[x];
      n = n.toFixed(1);
      cpos[x] = n;
    }
    
    // Get the form controls
    eX = document.getElementById("txtCamX");
    if (eX == null) {
      fault(func_name, 101);
    }
    
    eY = document.getElementById("txtCamY");
    if (eY == null) {
      fault(func_name, 102);
    }
    
    eZ = document.getElementById("txtCamZ");
    if (eZ == null) {
      fault(func_name, 103);
    }
    
    eYaw = document.getElementById("txtCamYaw");
    if (eYaw == null) {
      fault(func_name, 104);
    }
    
    ePitch = document.getElementById("txtCamPitch");
    if (ePitch == null) {
      fault(func_name, 105);
    }
    
    eRoll = document.getElementById("txtCamRoll");
    if (eRoll == null) {
      fault(func_name, 106);
    }
    
    // Update each form control
    eX.value     = cpos[0];
    eY.value     = cpos[1];
    eZ.value     = cpos[2];
    eYaw.value   = cpos[3];
    ePitch.value = cpos[4];
    eRoll.value  = cpos[5];
  }
  
  /*
   * Attempt to update the camera position using the current values of
   * the form controls.
   *
   * If any of the values are invalid, the camera position is not
   * changed, the camera error box is displayed with the appropriate
   * message, and the input boxes retain their current values.
   *
   * If the values are valid, they are used to update the camera
   * position, the input boxes are updated with the new current
   * position, and the canvas is re-drawn.
   *
   * Note that the values may change on the update due to rounding and
   * other adjustments.
   */
  function writeCamera() {
    
    var func_name = "writeCamera";
    var eX, eY, eZ, eYaw, ePitch, eRoll;
    var vx, vy, vz, vyaw, vpitch, vroll;
    
    // Dismiss any current camera error
    dismiss("divCamError");
    
    // Get the form controls
    eX = document.getElementById("txtCamX");
    if (eX == null) {
      fault(func_name, 101);
    }
    
    eY = document.getElementById("txtCamY");
    if (eY == null) {
      fault(func_name, 102);
    }
    
    eZ = document.getElementById("txtCamZ");
    if (eZ == null) {
      fault(func_name, 103);
    }
    
    eYaw = document.getElementById("txtCamYaw");
    if (eYaw == null) {
      fault(func_name, 104);
    }
    
    ePitch = document.getElementById("txtCamPitch");
    if (ePitch == null) {
      fault(func_name, 105);
    }
    
    eRoll = document.getElementById("txtCamRoll");
    if (eRoll == null) {
      fault(func_name, 106);
    }
    
    // Parse each value as a float
    vx = parseFloat(eX.value);
    if (!isFinite(vx)) {
      writeTo("spnCamReason", "Can't parse X as a float");
      present("divCamError");
      return;
    }
    
    vy = parseFloat(eY.value);
    if (!isFinite(vy)) {
      writeTo("spnCamReason", "Can't parse Y as a float");
      present("divCamError");
      return;
    }
    
    vz = parseFloat(eZ.value);
    if (!isFinite(vz)) {
      writeTo("spnCamReason", "Can't parse Z as a float");
      present("divCamError");
      return;
    }
    
    vyaw = parseFloat(eYaw.value);
    if (!isFinite(vyaw)) {
      writeTo("spnCamReason", "Can't parse yaw as a float");
      present("divCamError");
      return;
    }
    
    vpitch = parseFloat(ePitch.value);
    if (!isFinite(vpitch)) {
      writeTo("spnCamReason", "Can't parse pitch as a float");
      present("divCamError");
      return;
    }
    
    vroll = parseFloat(eRoll.value);
    if (!isFinite(vroll)) {
      writeTo("spnCamReason", "Can't parse roll as a float");
      present("divCamError");
      return;
    }

    // Yaw must be in range [-360, 360]
    if (!((vyaw >= -360.0) && (vyaw <= 360.0))) {
      writeTo("spnCamReason", "Yaw must be in range [-360, 360]");
      present("divCamError");
      return;
    }
    
    // Pitch must be in range [-90, 90]
    if (!((vpitch >= -90.0) && (vpitch <= 90.0))) {
      writeTo("spnCamReason", "Pitch must be in range [-90, 90]");
      present("divCamError");
      return;
    }
    
    // Roll must be in range [-360, 360]
    if (!((vroll >= -360.0) && (vroll <= 360.0))) {
      writeTo("spnCamReason", "Roll must be in range [-360, 360]");
      present("divCamError");
      return;
    }

    // If yaw or roll are negative, add 360 to them
    if (!(vyaw >= 0.0)) {
      vyaw = vyaw + 360.0;
    }
    if (!(vroll >= 0.0)) {
      vroll = vroll + 360.0;
    }

    // Convert yaw and roll to normalized angle space
    vyaw = vyaw / 360.0;
    vroll = vroll / 360.0;
    
    // Convert pitch to normalized angle space
    vpitch = vpitch / 90.0;

    // Clamp all angle values to their normalized spaces
    vyaw = Math.min(Math.max(0.0, vyaw), 1.0);
    vpitch = Math.min(Math.max(-1.0, vpitch), 1.0);
    vroll = Math.min(Math.max(0.0, vroll), 1.0);
    
    // For yaw and roll, if they are at 1.0, set to 0.0
    if (vyaw === 1.0) {
      vyaw = 0.0;
    }
    if (vroll === 1.0) {
      vroll = 0.0;
    }

    // Update camera position
    dla_main.setCamera(vx, vy, vz, vyaw, vpitch, vroll);
    
    // Write the new values to the the form controls
    readCamera();
    
    // Re-draw the canvas
    drawCanvas();
  }
  
  /*
   * Event handler for when the document is fully loaded.
   *
   * This should be registered later.
   */
  function handleLoad() {
    
    var func_name = "handleLoad";
    var e;
    
    // Load the default scene
    dla_main.loadDefaultScene();
    
    // @@TODO:
    
    // Add an event handler to resize box to automatically resize the
    // canvas to match the resize box value
    e = document.getElementById("optSize");
    if (e == null) {
      fault(func_name, 500);
    }
    e.onchange = resizeChanged;
    
    // Add an event handler to the file upload control to handle any
    // file that is selected there
    e = document.getElementById("uplFile");
    if (e == null) {
      fault(func_name, 510);
    }
    e.onchange = handleFile;
    
    // Update controls to reflect current state
    readCamera();
    
    // Hide the splash-screen DIV and show the main DIV
    e = document.getElementById("divSplash");
    if (e == null) {
      fault(func_name, 900);
    }
    e.style.display = "none";
    
    e = document.getElementById("divMain");
    if (e == null) {
      fault(func_name, 910);
    }
    e.style.display = "block";
    
    // Finally, draw the canvas
    drawCanvas();
  }

  /*
   * Export declarations
   * ===================
   * 
   * All exports are declared within a global "dla_html" object.
   */
  window.dla_html = {
    "dismiss": dismiss,
    "readCamera": readCamera,
    "writeCamera": writeCamera,
    "handleLoad": handleLoad
  };

}());

// Register the document loading event
window.onload = dla_html.handleLoad;

    </script>
  </head>
  <body>
  
    <!-- Screen displayed when JavaScript is disabled -->
    <noscript>
      <h1>Delilah Viewer</h1>
      <p>This web app requires JavaScript to function!</p>
    </noscript>
    
    <!-- Initial splash screen, except when JavaScript disabled -->
    <div id="divSplash">
      Loading web app...
    </div>
    
    <!-- The main program window, shown after page is loaded -->
    <div id="divMain">
      <canvas width="320" height="180" id="cnvMain">
        HTML5 canvas support is required!
      </canvas>
      <div id="divSizer">
        Canvas size:
        <select id="optSize" name="optSize">
          <!-- The format of the value fields is important -->
          <option value="size320x180" selected>320 x 180</option>
          <option value="size640x360">640 x 360</option>
          <option value="size800x450">800 x 450</option>
          <option value="size1024x576">1024 x 576</option>
          <option value="size1280x720">1280 x 720</option>
        </select>
      </div>
      <div id="divFileError">
        Failed to load scene file:<br/>
        <span id="spnFileReason">&nbsp;</span><br/>
        <br/>
        <a href="javascript:void dla_html.dismiss('divFileError');">
          Dismiss
        </a>
      </div>
      <div id="divFile">
        Scene file:<br/>
        <input type="file" id="uplFile" name="uplFile"/>
      </div>
      <div id="divCamError">
        Failed to update camera position:<br/>
        <span id="spnCamReason">&nbsp;</span><br/>
        <br/>
        <a href="javascript:void dla_html.dismiss('divCamError');">
          Dismiss
        </a>
      </div>
      <div id="divCam">
        <table>
          <tr>
            <th colspan="5">Camera position</th>
          </tr>
          <tr>
            <td class="lbl">X:</td>
            <td class="box">
              <input type="text" id="txtCamX" name="txtCamX"/>
            </td>
            <td class="lbl">Yaw:</td>
            <td class="abox">
              <input type="text" id="txtCamYaw" name="txtCamYaw"/>
            </td>
            <td class="suf">degrees</td>
          </tr>
          <tr>
            <td class="lbl">Y:</td>
            <td class="box">
              <input type="text" id="txtCamY" name="txtCamY"/>
            </td>
            <td class="lbl">Pitch:</td>
            <td class="abox">
              <input type="text" id="txtCamPitch" name="txtCamPitch"/>
            </td>
            <td class="suf">degrees</td>
          </tr>
          <tr>
            <td class="lbl">Z:</td>
            <td class="box">
              <input type="text" id="txtCamZ" name="txtCamZ"/>
            </td>
            <td class="lbl">Roll:</td>
            <td class="abox">
              <input type="text" id="txtCamRoll" name="txtCamRoll"/>
            </td>
            <td class="suf">degrees</td>
          </tr>
          <tr>
            <td colspan="5" class="btn">
              <input type="button" value="Set"
                onclick="dla_html.writeCamera()"/>
              <input type="button" value="Get"
                onclick="dla_html.readCamera()"/>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </body>
</html>

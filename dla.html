<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Delilah Viewer</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"/>
    <style>

body {
  padding-left: 0.25em;
  padding-right: 0.25em;
  margin-bottom: 3.5em;
  background-color: WhiteSmoke;
  color: black;
  font-family: serif;
}

:link {
  text-decoration: none;
  color: blue
}

:visited {
  text-decoration: none;
  color: blue
}

h1 {
  font-family: sans-serif;
}

#divSplash {
  font-style: italic;
}

#divMain {
  display: none;
}

#cnvMain {
 border: medium inset;
 padding: 0;
}

#divSizer {
  margin-top: 1em;
}

#divFileError {
  display: none;
  margin-top: 2em;
  font-weight: bold;
  color: red;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-top: 1em;
  padding-bottom: 1em;
  border: medium solid;
  background-color: white;
}

#spnFileReason {
  font-weight: normal;
  color: black;
}

#divFile {
  margin-top: 1em;
}

#divCamError {
  display: none;
  margin-top: 2em;
  font-weight: bold;
  color: red;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-top: 1em;
  padding-bottom: 1em;
  border: medium solid;
  background-color: white;
}

#spnCamReason {
  font-weight: normal;
  color: black;
}

#divCam {
  margin-top: 1em;
}

#divCam th {
  font-weight: normal;
  text-align: left;
  text-decoration: underline;
  padding-bottom: 0.5em;
}

#divCam .lbl {
  text-align: right;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divCam .suf {
  text-align: left;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divCam .box input {
  width: 5em;
}

#divCam .abox input {
  width: 3em;
}

#divCam .btn {
  text-align: left;
  padding-top: 0.5em;
}

#divProjError {
  display: none;
  margin-top: 2em;
  font-weight: bold;
  color: red;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-top: 1em;
  padding-bottom: 1em;
  border: medium solid;
  background-color: white;
}

#spnProjReason {
  font-weight: normal;
  color: black;
}

#divProj {
  margin-top: 1em;
}

#divProj th {
  font-weight: normal;
  text-align: left;
  text-decoration: underline;
  padding-bottom: 0.5em;
}

#divProj .lbl {
  text-align: right;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divProj .suf {
  text-align: left;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divProj .box input {
  width: 5em;
}

#divProj .btn {
  text-align: left;
  padding-top: 0.5em;
}

#divBGError {
  display: none;
  margin-top: 2em;
  font-weight: bold;
  color: red;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-top: 1em;
  padding-bottom: 1em;
  border: medium solid;
  background-color: white;
}

#spnBGReason {
  font-weight: normal;
  color: black;
}

#divBG {
  margin-top: 1em;
}

#divBG th {
  font-weight: normal;
  text-align: left;
  text-decoration: underline;
  padding-bottom: 0.5em;
}

#divBG .lbl {
  text-align: right;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divBG .suf {
  text-align: left;
  font-family: monospace;
  padding-left: 0.25em;
  padding-right: 0.25em;
}

#divBG .box input {
  width: 5em;
}

#divBG .btn {
  text-align: left;
  padding-top: 0.5em;
}

    </style>
    <!-- If JavaScript disabled, do not show the splash screen -->
    <noscript>
      <style>

#divSplash {
  display: None;
}

      </style>
    </noscript>

    <!-- Load JavaScript modules -->
    <script src="dla.js"></script>
    
    <!-- Embedded script is for presentation tier functionality -->
    <script>

// Wrap everything in an anonymous function that we immediately invoke
// after it is declared -- this prevents anything from being implicitly
// added to global scope
(function() {

  /*
   * Local data
   * ==========
   */
  
  /*
   * Flag set to true when a file load is in progress.
   */
  var m_file_load = false;

  /*
   * Local functions
   * ===============
   */
  
  /*
   * Report an error to console and throw an exception for a fault
   * occurring within this module.
   *
   * Parameters:
   *
   *   func_name : string - the name of the function in this module
   *
   *   loc : number(int) - the location within the function
   */
  function fault(func_name, loc) {
    
    // If parameters not valid, set to unknown:0
    if ((typeof func_name !== "string") || (typeof loc !== "number")) {
      func_name = "unknown";
      loc = 0;
    }
    loc = Math.floor(loc);
    if (!isFinite(loc)) {
      loc = 0;
    }
    
    // Report error to console
    console.log("Fault at " + func_name + ":" + String(loc) +
                  " in dla_html");
    
    // Throw exception
    throw ("dla_html:" + func_name + ":" + String(loc));
  }
  
  /*
   * Find the element with the given ID and set its innerHTML to the
   * given message.
   *
   * This function will properly escape any & < > characters in the
   * message.
   *
   * Also, the given string will be trimmed of whitespace.  If this
   * results in an empty string, the string will be replaced with
   * "&nbsp;"
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to set
   *
   *   msg : string - the (unescaped) message to set
   */
  function writeTo(elid, msg) {
    
    var func_name = "present";
    var e;
    
    // Check parameters
    if ((typeof elid !== "string") || (typeof msg !== "string")) {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Trim message
    msg = msg.trim();
    
    // Escape the & characters first
    msg = msg.replace("&", "&amp;");
    
    // Escape the < > characters second
    msg = msg.replace("<", "&lt;");
    msg = msg.replace(">", "&gt;");
    
    // Finally, if message is empty, replace with &nbsp;
    if (msg.length < 1) {
      msg = "&nbsp;";
    }
    
    // Write the message
    e.innerHTML = msg;
  }
  
  /*
   * Find the element with the given ID and set its display property to
   * "block" to show it.
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to show
   */
  function present(elid) {
    
    var func_name = "present";
    var e;
    
    // Check parameter
    if (typeof elid !== "string") {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Show the element
    e.style.display = "block";
  }
  
  /*
   * Redraw the scene in the canvas.
   */
  function drawCanvas() {
    
    var func_name = "drawCanvas";
    var eCanvas;
    var rc, w, h;
    
    // Get the canvas element
    eCanvas = document.getElementById("cnvMain");
    if (eCanvas == null) {
      fault(func_name, 100);
    }
    
    // Get the width and height
    w = eCanvas.width;
    h = eCanvas.height;
    
    // Only proceed if both width and height are greater than zero
    if ((w > 0) && (h > 0)) {
      
      // Get a 2D rendering context
      rc = eCanvas.getContext("2d");
      if (rc == null) {
        fault(func_name, 200);
      }
      
      // Do full render if both width and height are greater than one,
      // else just blank to transparent black
      if ((w > 1) && (h > 1)) {
        dla_main.renderScene(rc, w, h);
        
      } else {
        rc.clearRect(0, 0, w, h);
      }
    }
  }

  /*
   * Event handler for handling changes to the canvas size option box.
   */
  function resizeChanged() {
    
    var func_name = "resizeChanged";
    var eOpt;
    var eCanvas;
    var sv;
    var sza;
    var i;
    var j;
    var c;
    var new_width;
    var new_height;
    
    // Get the size option control and the canvas
    eOpt = document.getElementById("optSize");
    eCanvas = document.getElementById("cnvMain");
    
    if ((eOpt == null) || (eCanvas == null)) {
      fault(func_name, 100);
    }
    
    // Get the string value of the option control
    sv = eOpt.value;
    
    // String value must be at least seven characters to be valid
    if (sv.length < 7) {
      fault(func_name, 200);
    }
    
    // First four characters must be "size"
    if (sv.slice(0, 4) !== "size") {
      fault(func_name, 300);
    }
    
    // Drop the first four characters
    sv = sv.slice(4);
    
    // Rest of the string value should be split around an "x" delimiter
    sza = sv.split("x");
    if (sza.length !== 2) {
      fault(func_name, 400);
    }
    
    // Both of the field elements should be at least one character
    if ((sza[0].length < 1) || (sza[1].length < 1)) {
      fault(func_name, 500);
    }
    
    // Both field elements should only have decimal digits
    for(j = 0; j < sza.length; j++) {
      for(i = 0; i < sza[j].length; i++) {
        c = sza[j].charCodeAt(i);
        if ((c < 0x30) || (c > 0x39)) {
          fault(func_name, 600);
        }
      }
    }
    
    // We can now get the desired width and height
    new_width = parseInt(sza[0], 10);
    new_height = parseInt(sza[1], 10);
    
    if ((!isFinite(new_width)) || (!isFinite(new_height))) {
      fault(func_name, 650);
    }
    
    // Check that new width and height are at least two
    if ((new_width < 2) || (new_height < 2)) {
      fault(func_name, 675);
    }
    
    // Ignore the event if new width and height same as current
    // dimensions
    if ((new_width === eCanvas.width) && 
        (new_height === eCanvas.height)) {
      return;
    }
    
    // If we got here, resize the canvas
    eCanvas.width = new_width;
    eCanvas.height = new_height;
    
    // Redraw canvas
    drawCanvas();
  }

  /*
   * Event handler for when the scene file control is changed.
   */
  function handleFile(event) {
    
    var func_name = "handleFile";
    var e;
    var f, r;
    
    // If file load already in progress, ignore this event
    if (m_file_load) {
      return;
    }
    
    // Dismiss the file error if it is being displayed
    dismiss("divFileError");
    
    // Get the file control
    e = document.getElementById("uplFile");
    if (e == null) {
      fault(func_name, 100);
    }
    
    // Check whether at least one file selected
    if (e.files.length > 0) {
      // At least one file selected, so get the file object
      f = e.files.item(0);
      
      // We don't want to get another file while we are waiting for the
      // current file to load, so hide the DIV containing the control
      // and set the m_file_load flag
      e = document.getElementById("divFile");
      if (e == null) {
        fault(func_name, 200);
      }
      e.style.display = "none";
      m_file_load = true;
      
      // Get a file reader object
      r = new FileReader();
      
      // Add an asynchronous handler that is always called at the end of
      // the operation, whether successful or not, that will clear the
      // file load flag and show the file DIV again
      r.addEventListener("loadend", function(ev) {
        m_file_load = false;
        e.style.display = "block";
      });
      
      // Define an asynchronous handler that will be invoked once the
      // whole file has been successfully read as a string
      r.addEventListener("load", function(ev) {
        
        // Load the scene, redrawing canvas if successful, showing error
        // message if unsuccessful
        if (dla_main.loadScene(ev.target.result)) {
          drawCanvas();
        } else {
          writeTo("spnFileReason", dla_main.loadError());
          present("divFileError");
        }
      });
      
      // Asynchronously read the file as text
      r.readAsText(f);
      
    } else {
      // No files selected, so load default scene
      dla_main.loadDefaultScene();
    }
  }

  /*
   * Given a field of view in degrees, in range [1, 179], find the limit
   * value of the near plane, which the near plane must be LESS than.
   *
   * Parameters:
   *
   *   fov : number - the field of view in degrees
   *
   * Return:
   *
   *   limit value of the near plane
   */
  function computeNearLimit(fov) {
    
    var func_name = "computeNearLimit";
    var lv;
    
    // Check that value is finite number
    if (typeof fov !== "number") {
      fault(func_name, 100);
    }
    if (!isFinite(fov)) {
      fault(func_name, 200);
    }
    
    // Check that value is in range
    if (!((fov >= 1.0) && (fov <= 179.0))) {
      fault(func_name, 300);
    }
    
    // Compute the near plane limit, setting to zero if error
    lv = 1 / (Math.tan((fov / 2.0) * Math.PI / 180));
    if (!isFinite(lv)) {
      lv = 0.0;
    }
    
    // Return result
    return lv;
  }

  /*
   * Read the value from the FOV and if it is valid, update the near
   * limit box with the new computed value, else set the box to empty.
   */
  function updateNearLimit() {
    
    var func_name = "updateNearLimit";
    var eFOV, eLimit;
    var fov, lv;
    
    // Get the controls
    eFOV = document.getElementById("txtProjFOV");
    eLimit = document.getElementById("txtProjLimit");
    
    if ((eFOV == null) || (eLimit == null)) {
      fault(func_name, 100);
    }
    
    // Try to parse the FOV as a float
    fov = parseFloat(eFOV.value);
    if (!isFinite(fov)) {
      // Failed to parse, so clear limit box and return
      eLimit.value = "";
      return;
    }
    
    // FOV must be in range [1, 179] to be valid
    if (!((fov >= 1) && (fov <= 179))) {
      // FOV out of range
      eLimit.value = "";
      return;
    }
    
    // Compute the limit, setting to zero if computation error
    lv = computeNearLimit(fov);
    
    // Convert to string with two decimal places
    lv = lv.toFixed(2);
    
    // Update the limit box
    eLimit.value = lv;
  }

  /*
   * Public functions
   * ================
   */
  
  /*
   * Find the element with the given ID and set its display property to
   * "none" to hide it.
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to hide
   */
  function dismiss(elid) {
    
    var func_name = "dismiss";
    var e;
    
    // Check parameter
    if (typeof elid !== "string") {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Hide the element
    e.style.display = "none";
  }
  
  /*
   * Read the current background color and update the display controls
   * with the current background.
   *
   * This also hides any background color error message that may be
   * displayed.
   */
  function readBG() {
  
    var func_name = "readBG";
    var a, rgb;
    var eBG;
    
    // Dismiss any background color error
    dismiss("divBGError");
    
    // Get the background color as an array of three values
    a = dla_main.getBGColor();
    
    // Pack color channels into single RGB value
    rgb = (a[0] << 16) | (a[1] << 8) | a[2];
    
    // Convert to base-16
    rgb = rgb.toString(16);
    
    // Zero-pad up to six characters
    while (rgb.length < 6) {
      rgb = "0" + rgb;
    }
    
    // Get the form control
    eBG = document.getElementById("txtBGColor");
    if (eBG == null) {
      fault(func_name, 101);
    }
    
    // Update the form control
    eBG.value = rgb;
  }
  
  /*
   * Attempt to update the background color using the current values of
   * the form controls.
   *
   * If the input value is invalid, the background color is not changed,
   * the background color error box is displayed, and the input box
   * retains its current value.
   *
   * If the value is valid, it is used to update the background color,
   * the input box is updated with the new current background color, and
   * the canvas is re-drawn.
   *
   * Note that the value may change on the update due to normalization
   * of the color value.
   */
  function writeBG() {
    
    var func_name = "writeBG";
    var eBG;
    var rgb, r, g, b;
    
    // Dismiss any current background color error
    dismiss("divBGError");
    
    // Get the form controls
    eBG = document.getElementById("txtBGColor");
    if (eBG == null) {
      fault(func_name, 101);
    }
    
    // Get the string value and trim
    rgb = eBG.value.trim();
    
    // Must be exactly six characters after trimming
    if (rgb.length !== 6) {
      present("divBGError");
      return;
    }
    
    // Parse the value as a base-16 integer
    rgb = parseInt(rgb, 16);
    if (!isFinite(rgb)) {
      present("divBGError");
      return;
    }

    // Value must be in range [0, 0xffffff]
    if (!((rgb >= 0) && (rgb <= 0xffffff))) {
      present("divBGError");
      return;
    }
    
    // Get the R G B channel values
    r = rgb >> 16;
    g = (rgb >> 8) & 0xff;
    b = rgb & 0xff;

    // Update background color
    dla_main.setBGColor(r, g, b);
    
    // Write the new value to the the form control
    readBG();
    
    // Re-draw the canvas
    drawCanvas();
  }
  
  /*
   * Read the current projection and update the display controls with
   * the current projection.
   *
   * This also hides any projection error message that may be displayed,
   * as well as invoking updateNearLimit() at the end to update the
   * computed box.
   */
  function readProj() {
    
    var func_name = "readProj";
    var pdat;
    var eFOV, eNear, eFar;
    
    // Dismiss any projection error
    dismiss("divProjError");
    
    // Get the projection data
    pdat = dla_main.getProjection();
    
    // Convert normalized angle to degrees
    pdat[0] = pdat[0] * 180.0;
    
    // Clamp normalized angle to [1, 179]
    pdat[0] = Math.min(Math.max(pdat[0], 1.0), 179.0);
    
    // Clamp near plane so that it is at least 0.0135 units below the
    // limit
    pdat[1] = Math.min(pdat[1], computeNearLimit(pdat[0]) - 0.0135);
    
    // Clamp far plane so that it is at least 0.0135 units below the
    // near plane
    pdat[2] = Math.min(pdat[2], pdat[1] - 0.0135);
    
    // Get the form controls
    eFOV = document.getElementById("txtProjFOV");
    if (eFOV == null) {
      fault(func_name, 101);
    }
    
    eNear = document.getElementById("txtProjNear");
    if (eNear == null) {
      fault(func_name, 102);
    }
    
    eFar = document.getElementById("txtProjFar");
    if (eFar == null) {
      fault(func_name, 103);
    }
    
    // Update each form control
    eFOV.value  = pdat[0].toFixed(1);
    eNear.value = pdat[1].toFixed(2);
    eFar.value  = pdat[2].toFixed(2);
    
    // Update the computed near limit
    updateNearLimit();
  }
  
  /*
   * Attempt to update the projection using the current values of the
   * form controls.
   *
   * If any of the values are invalid, the projection is not changed,
   * the projection error box is displayed with the appropriate message,
   * and the input boxes retain their current values.
   *
   * If the values are valid, they are used to update the projection,
   * the input boxes are updated with the new current position, and the
   * canvas is re-drawn.
   *
   * Note that the values may change on the update due to rounding and
   * other adjustments.
   */
  function writeProj() {
    
    var func_name = "writeProj";
    var eFOV, eNear, eFar;
    var fov, near, far;
    
    // Dismiss any current projection error
    dismiss("divProjError");
    
    // Get the form controls
    eFOV = document.getElementById("txtProjFOV");
    if (eFOV == null) {
      fault(func_name, 101);
    }
    
    eNear = document.getElementById("txtProjNear");
    if (eNear == null) {
      fault(func_name, 102);
    }
    
    eFar = document.getElementById("txtProjFar");
    if (eFar == null) {
      fault(func_name, 103);
    }
    
    // Parse each value as a float
    fov = parseFloat(eFOV.value);
    if (!isFinite(fov)) {
      writeTo("spnProjReason", "Can't parse FOV as a float");
      present("divProjError");
      return;
    }
    
    near = parseFloat(eNear.value);
    if (!isFinite(near)) {
      writeTo("spnProjReason", "Can't parse near plane as a float");
      present("divProjError");
      return;
    }
    
    far = parseFloat(eFar.value);
    if (!isFinite(far)) {
      writeTo("spnProjReason", "Can't parse far plane as a float");
      present("divProjError");
      return;
    }
    
    // FOV must be in range [1, 179]
    if (!((fov >= 1) && (fov <= 179))) {
      writeTo("spnProjReason", "FOV must be in range [1.0, 179.0]");
      present("divProjError");
      return;
    }
    
    // Near plane must be less than limit
    if (!(near < computeNearLimit(fov))) {
      writeTo("spnProjReason", "Near plane must be less than limit");
      present("divProjError");
      return;
    }

    // Far plane must be less than near plane
    if (!(far < near)) {
      writeTo("spnProjReason", "Far plane must be less than near");
      present("divProjError");
      return;
    }

    // Clamp near plane to be at least 0.0135 units under limit
    near = Math.min(near, computeNearLimit(fov) - 0.0135);
    
    // Clamp far plane to be at least 0.0135 units under near
    far = Math.min(far, near - 0.0135);

    // Convert FOV to normalized angle space
    fov = fov / 180.0;

    // Update projection
    dla_main.setProjection(fov, near, far);
    
    // Write the new values to the the form controls
    readProj();
    
    // Re-draw the canvas
    drawCanvas();
  }
  
  /*
   * Read the current camera position and update the display controls
   * with the current position.
   *
   * This also hides any camera error message that may be displayed.
   */
  function readCamera() {
    
    var func_name = "readCamera";
    var cpos;
    var x, n;
    var eX, eY, eZ, eYaw, ePitch, eRoll;
    
    // Dismiss any camera error
    dismiss("divCamError");
    
    // Get the camera position
    cpos = dla_main.getCamera();
    
    // Convert normalized angles to degrees
    cpos[3] = cpos[3] * 360.0;
    cpos[4] = cpos[4] * 90.0;
    cpos[5] = cpos[5] * 360.0;
    
    // Transform each coordinate to a string, using one decimal place
    for(x = 0; x < 6; x++) {
      n = cpos[x];
      n = n.toFixed(1);
      cpos[x] = n;
    }
    
    // Get the form controls
    eX = document.getElementById("txtCamX");
    if (eX == null) {
      fault(func_name, 101);
    }
    
    eY = document.getElementById("txtCamY");
    if (eY == null) {
      fault(func_name, 102);
    }
    
    eZ = document.getElementById("txtCamZ");
    if (eZ == null) {
      fault(func_name, 103);
    }
    
    eYaw = document.getElementById("txtCamYaw");
    if (eYaw == null) {
      fault(func_name, 104);
    }
    
    ePitch = document.getElementById("txtCamPitch");
    if (ePitch == null) {
      fault(func_name, 105);
    }
    
    eRoll = document.getElementById("txtCamRoll");
    if (eRoll == null) {
      fault(func_name, 106);
    }
    
    // Update each form control
    eX.value     = cpos[0];
    eY.value     = cpos[1];
    eZ.value     = cpos[2];
    eYaw.value   = cpos[3];
    ePitch.value = cpos[4];
    eRoll.value  = cpos[5];
  }
  
  /*
   * Attempt to update the camera position using the current values of
   * the form controls.
   *
   * If any of the values are invalid, the camera position is not
   * changed, the camera error box is displayed with the appropriate
   * message, and the input boxes retain their current values.
   *
   * If the values are valid, they are used to update the camera
   * position, the input boxes are updated with the new current
   * position, and the canvas is re-drawn.
   *
   * Note that the values may change on the update due to rounding and
   * other adjustments.
   */
  function writeCamera() {
    
    var func_name = "writeCamera";
    var eX, eY, eZ, eYaw, ePitch, eRoll;
    var vx, vy, vz, vyaw, vpitch, vroll;
    
    // Dismiss any current camera error
    dismiss("divCamError");
    
    // Get the form controls
    eX = document.getElementById("txtCamX");
    if (eX == null) {
      fault(func_name, 101);
    }
    
    eY = document.getElementById("txtCamY");
    if (eY == null) {
      fault(func_name, 102);
    }
    
    eZ = document.getElementById("txtCamZ");
    if (eZ == null) {
      fault(func_name, 103);
    }
    
    eYaw = document.getElementById("txtCamYaw");
    if (eYaw == null) {
      fault(func_name, 104);
    }
    
    ePitch = document.getElementById("txtCamPitch");
    if (ePitch == null) {
      fault(func_name, 105);
    }
    
    eRoll = document.getElementById("txtCamRoll");
    if (eRoll == null) {
      fault(func_name, 106);
    }
    
    // Parse each value as a float
    vx = parseFloat(eX.value);
    if (!isFinite(vx)) {
      writeTo("spnCamReason", "Can't parse X as a float");
      present("divCamError");
      return;
    }
    
    vy = parseFloat(eY.value);
    if (!isFinite(vy)) {
      writeTo("spnCamReason", "Can't parse Y as a float");
      present("divCamError");
      return;
    }
    
    vz = parseFloat(eZ.value);
    if (!isFinite(vz)) {
      writeTo("spnCamReason", "Can't parse Z as a float");
      present("divCamError");
      return;
    }
    
    vyaw = parseFloat(eYaw.value);
    if (!isFinite(vyaw)) {
      writeTo("spnCamReason", "Can't parse yaw as a float");
      present("divCamError");
      return;
    }
    
    vpitch = parseFloat(ePitch.value);
    if (!isFinite(vpitch)) {
      writeTo("spnCamReason", "Can't parse pitch as a float");
      present("divCamError");
      return;
    }
    
    vroll = parseFloat(eRoll.value);
    if (!isFinite(vroll)) {
      writeTo("spnCamReason", "Can't parse roll as a float");
      present("divCamError");
      return;
    }

    // Yaw must be in range [-360, 360]
    if (!((vyaw >= -360.0) && (vyaw <= 360.0))) {
      writeTo("spnCamReason", "Yaw must be in range [-360, 360]");
      present("divCamError");
      return;
    }
    
    // Pitch must be in range [-90, 90]
    if (!((vpitch >= -90.0) && (vpitch <= 90.0))) {
      writeTo("spnCamReason", "Pitch must be in range [-90, 90]");
      present("divCamError");
      return;
    }
    
    // Roll must be in range [-360, 360]
    if (!((vroll >= -360.0) && (vroll <= 360.0))) {
      writeTo("spnCamReason", "Roll must be in range [-360, 360]");
      present("divCamError");
      return;
    }

    // If yaw or roll are negative, add 360 to them
    if (!(vyaw >= 0.0)) {
      vyaw = vyaw + 360.0;
    }
    if (!(vroll >= 0.0)) {
      vroll = vroll + 360.0;
    }

    // Convert yaw and roll to normalized angle space
    vyaw = vyaw / 360.0;
    vroll = vroll / 360.0;
    
    // Convert pitch to normalized angle space
    vpitch = vpitch / 90.0;

    // Clamp all angle values to their normalized spaces
    vyaw = Math.min(Math.max(0.0, vyaw), 1.0);
    vpitch = Math.min(Math.max(-1.0, vpitch), 1.0);
    vroll = Math.min(Math.max(0.0, vroll), 1.0);
    
    // For yaw and roll, if they are at 1.0, set to 0.0
    if (vyaw === 1.0) {
      vyaw = 0.0;
    }
    if (vroll === 1.0) {
      vroll = 0.0;
    }

    // Update camera position
    dla_main.setCamera(vx, vy, vz, vyaw, vpitch, vroll);
    
    // Write the new values to the the form controls
    readCamera();
    
    // Re-draw the canvas
    drawCanvas();
  }
  
  /*
   * Event handler for when the document is fully loaded.
   *
   * This should be registered later.
   */
  function handleLoad() {
    
    var func_name = "handleLoad";
    var e;
    
    // Load the default scene
    dla_main.loadDefaultScene();
    
    // Add an event handler to FOV box to automatically recalculate the
    // near limit
    e = document.getElementById("txtProjFOV");
    if (e == null) {
      fault(func_name, 490);
    }
    e.onchange = updateNearLimit;
    
    // Add an event handler to resize box to automatically resize the
    // canvas to match the resize box value
    e = document.getElementById("optSize");
    if (e == null) {
      fault(func_name, 500);
    }
    e.onchange = resizeChanged;
    
    // Add an event handler to the file upload control to handle any
    // file that is selected there
    e = document.getElementById("uplFile");
    if (e == null) {
      fault(func_name, 510);
    }
    e.onchange = handleFile;
    
    // Update controls to reflect current state
    readCamera();
    readProj();
    readBG();
    
    // Hide the splash-screen DIV and show the main DIV
    e = document.getElementById("divSplash");
    if (e == null) {
      fault(func_name, 900);
    }
    e.style.display = "none";
    
    e = document.getElementById("divMain");
    if (e == null) {
      fault(func_name, 910);
    }
    e.style.display = "block";
    
    // Finally, draw the canvas
    drawCanvas();
  }

  /*
   * Export declarations
   * ===================
   * 
   * All exports are declared within a global "dla_html" object.
   */
  window.dla_html = {
    "dismiss": dismiss,
    "readBG": readBG,
    "writeBG": writeBG,
    "readProj": readProj,
    "writeProj": writeProj,
    "readCamera": readCamera,
    "writeCamera": writeCamera,
    "handleLoad": handleLoad
  };

}());

// Register the document loading event
window.onload = dla_html.handleLoad;

    </script>
  </head>
  <body>
  
    <!-- Screen displayed when JavaScript is disabled -->
    <noscript>
      <h1>Delilah Viewer</h1>
      <p>This web app requires JavaScript to function!</p>
    </noscript>
    
    <!-- Initial splash screen, except when JavaScript disabled -->
    <div id="divSplash">
      Loading web app...
    </div>
    
    <!-- The main program window, shown after page is loaded -->
    <div id="divMain">
      <canvas width="320" height="180" id="cnvMain">
        HTML5 canvas support is required!
      </canvas>
      <div id="divSizer">
        Canvas size:
        <select id="optSize" name="optSize">
          <!-- The format of the value fields is important -->
          <option value="size320x180" selected>320 x 180</option>
          <option value="size640x360">640 x 360</option>
          <option value="size800x450">800 x 450</option>
          <option value="size1024x576">1024 x 576</option>
          <option value="size1280x720">1280 x 720</option>
        </select>
      </div>
      <div id="divFileError">
        Failed to load scene file:<br/>
        <span id="spnFileReason">&nbsp;</span><br/>
        <br/>
        <a href="javascript:void dla_html.dismiss('divFileError');">
          Dismiss
        </a>
      </div>
      <div id="divFile">
        Scene file:<br/>
        <input type="file" id="uplFile" name="uplFile"/>
      </div>
      <div id="divCamError">
        Failed to update camera position:<br/>
        <span id="spnCamReason">&nbsp;</span><br/>
        <br/>
        <a href="javascript:void dla_html.dismiss('divCamError');">
          Dismiss
        </a>
      </div>
      <div id="divCam">
        <table>
          <tr>
            <th colspan="5">Camera position</th>
          </tr>
          <tr>
            <td class="lbl">X:</td>
            <td class="box">
              <input type="text" id="txtCamX" name="txtCamX"/>
            </td>
            <td class="lbl">Yaw:</td>
            <td class="abox">
              <input type="text" id="txtCamYaw" name="txtCamYaw"/>
            </td>
            <td class="suf">degrees</td>
          </tr>
          <tr>
            <td class="lbl">Y:</td>
            <td class="box">
              <input type="text" id="txtCamY" name="txtCamY"/>
            </td>
            <td class="lbl">Pitch:</td>
            <td class="abox">
              <input type="text" id="txtCamPitch" name="txtCamPitch"/>
            </td>
            <td class="suf">degrees</td>
          </tr>
          <tr>
            <td class="lbl">Z:</td>
            <td class="box">
              <input type="text" id="txtCamZ" name="txtCamZ"/>
            </td>
            <td class="lbl">Roll:</td>
            <td class="abox">
              <input type="text" id="txtCamRoll" name="txtCamRoll"/>
            </td>
            <td class="suf">degrees</td>
          </tr>
          <tr>
            <td colspan="5" class="btn">
              <input type="button" value="Set"
                onclick="dla_html.writeCamera()"/>
              <input type="button" value="Get"
                onclick="dla_html.readCamera()"/>
            </td>
          </tr>
        </table>
      </div>
      <div id="divProjError">
        Failed to update projection:<br/>
        <span id="spnProjReason">&nbsp;</span><br/>
        <br/>
        <a href="javascript:void dla_html.dismiss('divProjError');">
          Dismiss
        </a>
      </div>
      <div id="divProj">
        <table>
          <tr>
            <th colspan="3">Projection</th>
          </tr>
          <tr>
            <td class="lbl">FOV (vertical):</td>
            <td class="box">
              <input type="text" id="txtProjFOV" name="txtProjFOV"/>
            </td>
            <td class="suf">degrees</td>
          </tr>
          <tr>
            <td class="lbl">Near plane limit:</td>
            <td class="box">
              <input type="text"
                id="txtProjLimit" name="txtProjLimit"
                readonly="readonly"/>
            </td>
            <td class="suf">(computed from FOV)</td>
          </tr>
          <tr>
            <td class="lbl">Near plane:</td>
            <td class="box">
              <input type="text" id="txtProjNear" name="txtProjNear"/>
            </td>
            <td class="suf">&nbsp;</td>
          </tr>
          <tr>
            <td class="lbl">Far plane:</td>
            <td class="box">
              <input type="text" id="txtProjFar" name="txtProjFar"/>
            </td>
            <td class="suf">&nbsp;</td>
          </tr>
          <tr>
            <td colspan="3" class="btn">
              <input type="button" value="Set"
                onclick="dla_html.writeProj()"/>
              <input type="button" value="Get"
                onclick="dla_html.readProj()"/>
            </td>
          </tr>
        </table>
      </div>
      <div id="divBGError">
        Failed to update background color:<br/>
        <span id="spnBGReason">Color must be exactly six base-16 digits
        in RRGGBB order</span><br/>
        <br/>
        <a href="javascript:void dla_html.dismiss('divBGError');">
          Dismiss
        </a>
      </div>
      <div id="divBG">
        <table>
          <tr>
            <th colspan="3">Background color</th>
          </tr>
          <tr>
            <td class="lbl">Hex code:</td>
            <td class="box">
              <input type="text" id="txtBGColor" name="txtBGColor"/>
            </td>
            <td class="suf">(RRGGBB)</td>
          </tr>
          <tr>
            <td colspan="3" class="btn">
              <input type="button" value="Set"
                onclick="dla_html.writeBG()"/>
              <input type="button" value="Get"
                onclick="dla_html.readBG()"/>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </body>
</html>
